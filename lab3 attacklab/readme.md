# CSAPP lab3 Attacklab

### **Part I: Code Injection Attacks**

#### **Level1:**

要在执行 `getbuf` 的时候调用 `touch1`，也就是说不能让 `getbuf return` 到正确的地址。从汇编代码看 `getbuf`占栈上的40个字节，那就用任意内容把40个字节给填满，然后再后面跟 `touch1` 的初始地址，覆盖掉原来储存的正确返回地址。最后再用 `hex2raw` 转换一下生成一个新文件并喂给 `ctarget` 就行了。

#### Level2：

和第一题有点像，在 `getbuf` 要调用到 `touch2`，肯定也是覆盖原来的返回地址。和 `touch`1不同的是，`touch2` 有一个参数，从c语言代码来看，参数的值要和 `cookie (0x59b997fa)` 一样。通常来讲 `%rdi` 寄存器是存放第一个参数的地方（实验文档上也给了提示），那我们将 cookie 的值赋给 `%rdi` 就行了。因为要传参，所以不能像level1 直接把返回地址改成 `touch2` 的起始地址，实验文档提示用 `ret` 来操作。先像 level1 一样，填40个字符，然后后面跟一开始栈顶的位置。用`·gdb`在 `getbuf` 开始的地方打一个断点，`info reg` 读出 `%rsp` 的位置 `(0x5561dca0)` 再减去 `0x28`，所以栈顶的位置就是 `0x5561dc78`。再处理传参和调用的事情，除了给 `%rdi` 赋值之外，还要把 `touch2` 的起始地址压入栈，最后 `ret`。将这些事情用汇编语言写成 `level2.s` 进行编译再反编译就可以得到序列指令。填充的内容先是序列指令，不到40字节的部分任意数字填充，然后跟 `78 dc 61 55`。`hex2raw` 转一下给 `ctarget` 即可。

#### **Level3:** 

和前两题思路类似，但是涉及到了函数 `hexmatch` 和 `strncmp` 的调用，可能会把原来栈空间的内容给覆盖掉。从`touch3` 的代码来看输入的字符串要和 `cookie` 的编码一样，通过 `man ascii` 查询，为“35 39 62 39 37 66 61“ 。既然 `getbuf` 的栈帧可能被覆盖，那我们就把 `cookie` 的编码写到再上一层调用也就是 `test` 的栈帧中。用gdb 打断点到 `test` 的起始点，`info reg` 查到 `%rsp` 为 `0x5561dcb0`，减去 `0x8` 也就是 `0x5561dca8`。和上一题一样，将我们存放 cookie 的地址传给%rdi作为参数，然后把 `touch3` 的起始位置压入栈，后面再 `ret`。把文件给用gcc编译一下再反编译就可以得到序列指令。填充的内容先是序列指令，不到40字节的部分任意数字填充，然后跟78 dc 61 55（`getbuf`栈顶的位置），然后用0填充四个字节（根据上题可知栈底是 `0x5561dca0`，和`test` 的 `0x5561dca8` 差8个字节，前面已经覆盖了四个字节），最后再跟 `cookie` 的编码 “35 39 62 39 39 37 66 61” 和终止符 “00”。将 `txt` 文件用 `hex2raw` 转换一下喂给 `ctarget` 即可。



### **Part II: Return-Oriented Programming**

#### **Level2.2**：

要求还是调用 `touch2`，并传参。由于随机化栈了，就不能使用 `mov` 直接来传 `cookie` 的值了。根据实验文档的提示，我们可以用 `popq` 和 `movq` 组合来实现，且只用两个 `gadget`，`gadget` 在 `start_farm` 和 `mid_farm` 之间。思路是将 `cookie` 先存在栈中，然后 `pop` 出去存到一个寄存器中，再 `movq` 转存到 `%rdi` 中（或者直接`popq %rdi`，但是没有这样的 `gadget`）。根据文档中的机器码在 `farm` 的反汇编文件中找，很快就能发现`getval_280` 中的 `58 90 c3` 是 `popq %rax` 的机器码，`setval_426` 中的 `48 89 c7 90 c3` 是 `movq %rax, %rdi` 的机器码（中间都多加了 `nop`，但无所谓）。然后到 `rtarget` 的反汇编文件中找到这两个函数的位置，`getval_280` 在 `0x4019ca`，`58 90 c3` 的位置加上 `0x2` 就是 `0x4019cc`，`setval_426` 在 `0x4019c3`，`48 89 c7 90 c3` 的位置加上 `0x2` 为 `0x4019c5` 。所以输入的字符串先老样子任意填40个字符，然后是 `cc 19 40` 后面跟五个00保证地址正确，再是 `cookie` 的值，后面跟着第二个 `gadget` 的位置 `c5 19 40` ，跟五个00，最后是 `touch2` 的位置 `ec 17 40`。将 `txt` 文件用 `hex2raw` 转换一下喂给 `rtarget`，成功。

#### **Level3.2:** 

实际上这题大体思路 level3 很像，就是要把 `cookie` 的编码存到 `test` 的栈帧里。麻烦是不知道栈帧的绝对位置，但是可以通过 `%rsp` 的位置来用相对位置反推。然后用和上一题差不多的方法，地址没法直接直接操作，那就用 `popq` 操作转到寄存器上操作。在翻 `farm` 的反编译的时候，有一个 `add_xy` 函数很特别，它刚好可以完成寄存器相加的操作 `(%rax=%rdi+%rsi)`。那肯定是一系列操作让 `%rsi` 和 `%rdi` 一个存 `%rsp` 的地址，一个存偏移量，用 `add_xy` 完成相加，最后再把 `%rax`（存放cookie编码的地址）的值传给 `%rdi`，然后调用 `touch3`。（接下来这段找反汇编码太烦了orz.；过程有些长，查找的步骤省略，直接给地址，`gadget` 没有用的步骤也省略）首先来处理偏移量，和上题一样，`popq %rax (cc 19 40)` ，再是偏移量（这个先待定，要等后面都出来了在算），然后`movl %eax, %edx (dd 19 40)`，`movl %edx, %ecx (69 1a 40)`,  `movl %ecx, %esi (27 1a 40)`，这样偏移量就存到%rsi里了。接下来解决 `%rsp`，`movq %rsp, %rax (05 1a 40)`，`movq %rax, %rdi (c5 19 40)`，这样 `%rsp` 也存到 `%rdi` 里了。再执行寄存器加法 `lea (%rdi,%rsi,1)`, `%rax (d6 19 40)` ，并`movq %rax, %rdi (c5 19 40)`。这样传参的线路就完整了，然后后面是 `touch3` 的地址`fa 18 40`，最后是`cookie` 的编码 `35 39 62 39 39 37 66 61`。最后的最后计算一下偏移量，差4部到`cookie`编码存放的位置，所以就是加 `8*4=0x20`。当然字符串最前面还是任意填充40位。齐活儿，然后老套路走一遍，成功！



### **成功截图：**

![image1](.\pictures\image1.png)

![image2](.\pictures\image2.png)

![image3](.\pictures\image3.png)

![image4](.\pictures\image4.png)

![image5](.\pictures\image5.png)
